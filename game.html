<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>space combat period</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000010;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      height: 100%;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(circle at 50% 50%, #05051a 0%, #02020a 55%, #000000 100%);
      cursor: crosshair;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<script>
"use strict";

const SAVE_KEY = "eh_galaxy_save_v4";
const TAU = Math.PI * 2;

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

const keys = {};
const mouse = { x: 0, y: 0, worldX: 0, worldY: 0, down: false };

canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
});

let uiClickRegions = [];
function addUIClickRegion(x, y, w, h, onClick) {
  uiClickRegions.push({ x, y, w, h, onClick });
}

function handleUIClick(mx, my) {
  for (const r of uiClickRegions) {
    if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
      if (typeof r.onClick === "function") r.onClick();
      return true;
    }
  }
  return false;
}

canvas.addEventListener("mousedown", (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  if (state.ui.paused || state.ui.mapOpen) {
    handleUIClick(mx, my);
  } else {
    mouse.down = true;
  }
});

window.addEventListener("mouseup", () => {
  mouse.down = false;
});

window.addEventListener("keydown", (e) => {
  keys[e.code] = true;
  if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space"].includes(e.code)) {
    e.preventDefault();
  }
  onKeyDown(e);
});

window.addEventListener("keyup", (e) => {
  keys[e.code] = false;
});

function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function randRange(rng, min, max) {
  return min + (max - min) * rng();
}

function randInt(rng, min, max) {
  return Math.floor(randRange(rng, min, max + 1));
}

function clamp(v, min, max) {
  return v < min ? min : v > max ? max : v;
}

function normalizeAngle(a) {
  while (a > Math.PI) a -= TAU;
  while (a < -Math.PI) a += TAU;
  return a;
}

function distanceFromHome(x, y) {
  return Math.sqrt(x * x + y * y);
}

function systemDifficulty(x, y) {
  const dist = distanceFromHome(x, y);
  const diff = 1 + dist * 0.5;
  return Math.min(diff, 10);
}

function systemKey(x, y) {
  return x + "," + y;
}

function createHullCatalog() {
  const result = [];
  const classes = [
    { baseName: "Скаут",       count: 10, baseRadius: 10, baseHp: 70,  baseThrust: 340, baseSpeed: 520, baseRegen: 4,  desc: "Лёгкая разведка" },
    { baseName: "Корвет",      count: 10, baseRadius: 11, baseHp: 90,  baseThrust: 320, baseSpeed: 480, baseRegen: 5,  desc: "Лёгкий ударный" },
    { baseName: "Истребитель", count: 10, baseRadius: 13, baseHp: 120, baseThrust: 300, baseSpeed: 440, baseRegen: 6,  desc: "Фронтовой боец" },
    { baseName: "Фрегат",      count: 10, baseRadius: 16, baseHp: 160, baseThrust: 260, baseSpeed: 380, baseRegen: 7,  desc: "Полутанк" },
    { baseName: "Крейсер",     count: 10, baseRadius: 18, baseHp: 210, baseThrust: 230, baseSpeed: 340, baseRegen: 8,  desc: "Тяжёлый корабль" }
  ];

  for (let ci = 0; ci < classes.length; ci++) {
    const cls = classes[ci];
    for (let i = 1; i <= cls.count; i++) {
      const hpScale = 1 + (i - 1) * 0.14;
      const speedScale = 1 - (i - 1) * 0.018;
      const thrustScale = 1 - (i - 1) * 0.02;
      const regenScale = 1 + (i - 1) * 0.10;

      let shape = "arrow";
      if (cls.baseName === "Скаут") shape = "arrow";
      else if (cls.baseName === "Корвет") shape = "delta";
      else if (cls.baseName === "Истребитель") shape = "spear";
      else if (cls.baseName === "Фрегат") shape = "hammer";
      else if (cls.baseName === "Крейсер") shape = "disk";

      let abilityType = null;
      let abilityPower = 0;
      let abilityDesc = "";
      if (cls.baseName === "Скаут" && i >= 7) {
        abilityType = "energy";
        abilityPower = 0.35 + (i - 7) * 0.05;
        abilityDesc = "Бонус к запасу и регенерации энергии гиперпрыжка";
      } else if (cls.baseName === "Корвет" && i >= 8) {
        abilityType = "loot";
        abilityPower = 0.25 + (i - 8) * 0.05;
        abilityDesc = "Доп. кредиты при сборе лута";
      } else if (cls.baseName === "Крейсер" && i >= 8) {
        abilityType = "aura";
        abilityPower = 10 + (i - 8) * 2;
        abilityDesc = "Постоянный урон по врагам рядом";
      }

      const hull = {
        id: result.length,
        name: cls.baseName + " Mk" + i,
        radius: cls.baseRadius + i * 0.5,
        maxHp: Math.round(cls.baseHp * hpScale),
        thrust: Math.max(120, cls.baseThrust * thrustScale),
        maxSpeed: Math.max(220, cls.baseSpeed * speedScale),
        friction: 0.985 - 0.002 * (ci / Math.max(1, classes.length - 1)),
        regen: cls.baseRegen * regenScale,
        desc: cls.desc,
        shape,
        abilityType,
        abilityPower,
        abilityDesc
      };
      result.push(hull);
    }
  }
  return result;
}

const hullTypes = createHullCatalog();

const weaponTypes = [
  {
    name: "Импульсная пушка",
    bulletSpeed: 650,
    cooldown: 0.18,
    damage: 1.2,
    spread: 0.05,
    projectiles: 1,
    color: "#ffffaa",
    type: "Пули",
    desc: "Быстрая универсальная пушка"
  },
  {
    name: "Рельсотрон",
    bulletSpeed: 900,
    cooldown: 0.55,
    damage: 3.5,
    spread: 0.01,
    projectiles: 1,
    color: "#aaffff",
    type: "Пули",
    desc: "Медленный, но жёсткий выстрел"
  },
  {
    name: "Шрапнельный бластер",
    bulletSpeed: 600,
    cooldown: 0.32,
    damage: 0.7,
    spread: 0.35,
    projectiles: 5,
    color: "#ffddaa",
    type: "Дробовик",
    desc: "Фронтальный шотган"
  },
  {
    name: "Лазерный луч",
    bulletSpeed: 1200,
    cooldown: 0.12,
    damage: 0.9,
    spread: 0.0,
    projectiles: 1,
    color: "#66ffff",
    type: "Лазер",
    desc: "Точный скоростной луч"
  },
  {
    name: "Плазменный излучатель",
    bulletSpeed: 700,
    cooldown: 0.28,
    damage: 2.0,
    spread: 0.08,
    projectiles: 2,
    color: "#ff66ff",
    type: "Плазма",
    desc: "Плотные плазменные заряды"
  },
  {
    name: "Ракетный залп",
    bulletSpeed: 520,
    cooldown: 0.75,
    damage: 4.0,
    spread: 0.25,
    projectiles: 3,
    color: "#ffaa66",
    explosiveRadius: 60,
    type: "Ракеты",
    desc: "Медленный, но мощный ракетный залп"
  }
];

const engineModules = [
  {
    name: "Стандартный двигатель",
    speedFactor: 1.0,
    desc: "Сбалансированный"
  },
  {
    name: "Овердрайв",
    speedFactor: 1.3,
    desc: "Максимальная скорость, сложнее контроль"
  },
  {
    name: "Тяжёлый привод",
    speedFactor: 0.85,
    desc: "Медленнее, но устойчивее"
  }
];

function hullPrice(hull) {
  return Math.round(hull.maxHp * 1.1 + hull.maxSpeed * 0.6 + hull.thrust * 0.4);
}

function weaponPrice(w) {
  const dps = (w.damage * w.projectiles) / Math.max(0.05, w.cooldown);
  return Math.round(dps * 60 + w.bulletSpeed * 0.2);
}

function enginePrice(e) {
  return Math.round(400 + e.speedFactor * 500);
}

function createDefaultQuests() {
  return {
    active: [
      {
        id: "clear_1_0",
        type: "clearSystem",
        title: "Зачистить систему [1,0]",
        targetX: 1,
        targetY: 0,
        rewardCredits: 300,
        rewardXp: 120,
        completed: false
      },
      {
        id: "clear_0_1",
        type: "clearSystem",
        title: "Зачистить систему [0,1]",
        targetX: 0,
        targetY: 1,
        rewardCredits: 300,
        rewardXp: 120,
        completed: false
      },
      {
        id: "clear_1_1",
        type: "clearSystem",
        title: "Зачистить систему [1,1]",
        targetX: 1,
        targetY: 1,
        rewardCredits: 450,
        rewardXp: 180,
        completed: false
      }
    ],
    completed: []
  };
}

const baseHull = hullTypes[0];
const baseEngine = engineModules[0];

const state = {
  systemX: 0,
  systemY: 0,
  starSystem: null,
  ship: {
    x: 0, y: 0,
    vx: 0, vy: 0,
    angle: 0,
    radius: baseHull.radius,
    thrust: baseHull.thrust * baseEngine.speedFactor,
    maxSpeed: baseHull.maxSpeed * baseEngine.speedFactor,
    friction: baseHull.friction,
    fireCooldown: 0,
    hp: baseHull.maxHp,
    maxHp: baseHull.maxHp,
    regen: baseHull.regen
  },
  bullets: [],
  enemies: [],
  loot: [],
  particles: [],
  time: 0,
  gateCooldown: 0,
  credits: 0,
  energy: {
    current: 100,
    max: 100,
    regen: 3
  },
  build: {
    engine: 0,
    weapon: 0
  },
  inventory: {
    ownedHullIndices: [0, 1, 2, 3, 4],
    activeHullIndex: 0,
    ownedWeaponIndices: [0, 1, 2],
    ownedEngineIndices: [0, 1, 2]
  },
  playerStats: {
    level: 1,
    xp: 0,
    xpToNext: 80,
    upgradePoints: 0,
    upgrades: {
      damage: 0,
      reload: 0,
      hp: 0,
      speed: 0,
      regen: 0,
      energy: 0
    }
  },
  visitedSystems: {},
  ui: {
    paused: false,
    tab: "main",
    mapOpen: false,
    mapCenterX: 0,
    mapCenterY: 0
  },
  hyperJump: {
    active: false,
    t: 0,
    duration: 1.4,
    fromX: 0,
    fromY: 0,
    toX: 0,
    toY: 0,
    dirX: 0,
    dirY: 0,
    mode: "gate"
  },
  currentHull: baseHull,
  currentEngine: baseEngine,
  currentWeapon: weaponTypes[0],
  quests: createDefaultQuests(),
  message: "",
  messageTimer: 0
};

let galaxyCache = {};

function showMessage(text, duration) {
  state.message = text;
  state.messageTimer = duration || 3;
}

function applyBuild(keepHpRatio) {
  const inv = state.inventory;
  if (!inv.ownedHullIndices.length) {
    inv.ownedHullIndices = [0];
    inv.activeHullIndex = 0;
  }
  inv.activeHullIndex = clamp(inv.activeHullIndex, 0, inv.ownedHullIndices.length - 1);
  const hullIndex = inv.ownedHullIndices[inv.activeHullIndex] || 0;
  const hull = hullTypes[hullIndex] || hullTypes[0];

  const engineIndex = clamp(state.build.engine, 0, engineModules.length - 1);
  const engine = engineModules[engineIndex];

  let weaponIndex = state.build.weapon;
  if (!state.inventory.ownedWeaponIndices.includes(weaponIndex)) {
    weaponIndex = state.inventory.ownedWeaponIndices[0] ?? 0;
    state.build.weapon = weaponIndex;
  }
  const weaponTemplate = weaponTypes[weaponIndex] || weaponTypes[0];

  state.currentHull = hull;
  state.currentEngine = engine;

  const ship = state.ship;
  const ps = state.playerStats;
  const u = ps.upgrades || {};

  const oldMaxHp = ship.maxHp || hull.maxHp;
  let ratio = keepHpRatio ? (ship.hp / (oldMaxHp || 1)) : 1;
  ratio = clamp(ratio, 0, 1);

  const hpBonus     = 1 + 0.18 * (u.hp || 0);
  const speedBonus  = 1 + 0.08 * (u.speed || 0);
  const regenBonus  = 1 + 0.18 * (u.regen || 0);
  const damageBonus = 1 + 0.22 * (u.damage || 0);
  const reloadBonus = 1 - 0.08 * (u.reload || 0);

  ship.radius = hull.radius;
  ship.maxHp = Math.round(hull.maxHp * hpBonus);
  ship.hp    = ship.maxHp * ratio;
  ship.thrust    = hull.thrust * engine.speedFactor * speedBonus;
  ship.maxSpeed  = hull.maxSpeed * engine.speedFactor * speedBonus;
  ship.friction  = hull.friction;
  ship.regen     = hull.regen * regenBonus;

  const wt = weaponTemplate;
  state.currentWeapon = {
    name: wt.name,
    bulletSpeed: wt.bulletSpeed,
    cooldown: Math.max(0.06, wt.cooldown * reloadBonus),
    damage: wt.damage * damageBonus,
    spread: wt.spread,
    projectiles: wt.projectiles,
    color: wt.color,
    type: wt.type,
    explosiveRadius: wt.explosiveRadius || 0,
    desc: wt.desc
  };

  const energyUp = u.energy || 0;
  const baseMaxEnergy = 100;
  const baseRegen = 3;
  state.energy.max = baseMaxEnergy + energyUp * 40;
  state.energy.regen = baseRegen + energyUp * 1.5;

  if (hull.abilityType === "energy") {
    state.energy.max *= (1 + hull.abilityPower);
    state.energy.regen *= (1 + hull.abilityPower);
  }

  if (state.energy.current == null) state.energy.current = state.energy.max;
  else state.energy.current = Math.min(state.energy.current, state.energy.max);
}

function addXp(amount) {
  const ps = state.playerStats;
  const gain = Math.max(0, amount || 0);
  ps.xp += gain;
  while (ps.xp >= ps.xpToNext) {
    ps.xp -= ps.xpToNext;
    ps.level++;
    ps.upgradePoints++;
    ps.xpToNext = Math.floor(ps.xpToNext * 1.45 + 20);
    showMessage("Новый уровень: " + ps.level + " (+1 очко улучшений)");
  }
}

function canModifyShip() {
  const sys = state.starSystem;
  if (!sys) return false;
  if (state.systemX === 0 && state.systemY === 0) return true;
  const enemiesAlive = state.enemies.some(e => e.alive);
  const hostileBasesAlive = sys.bases.some(b => b.alive && !b.isPeaceful);
  return !enemiesAlive && !hostileBasesAlive;
}

function spendUpgrade(statKey) {
  if (!canModifyShip()) {
    showMessage("Улучшать можно только в зачищенной системе.");
    return;
  }
  const ps = state.playerStats;
  if (ps.upgradePoints <= 0) return;
  if (ps.upgrades[statKey] == null) ps.upgrades[statKey] = 0;
  ps.upgradePoints--;
  ps.upgrades[statKey]++;

  let txt = "";
  if (statKey === "damage") txt = "Урон оружия";
  else if (statKey === "reload") txt = "Скорострельность";
  else if (statKey === "hp") txt = "Прочность корпуса";
  else if (statKey === "speed") txt = "Скорость / манёвренность";
  else if (statKey === "regen") txt = "Регенерация";
  else if (statKey === "energy") txt = "Энергия гиперпрыжков";

  applyBuild(true);
  saveGame();
  if (txt) showMessage("Улучшено: " + txt);
}

function cycleHull(dir) {
  if (!canModifyShip()) {
    showMessage("Менять корабль можно только в зачищенной системе.");
    return;
  }
  const inv = state.inventory;
  if (!inv.ownedHullIndices.length) return;
  inv.activeHullIndex =
    (inv.activeHullIndex + dir + inv.ownedHullIndices.length) %
    inv.ownedHullIndices.length;
  applyBuild(true);
  saveGame();
  showMessage("Корабль: " + state.currentHull.name);
}

function setEngine(index) {
  if (!canModifyShip()) {
    showMessage("Менять двигатель можно только в зачищенной системе.");
    return;
  }
  if (!state.inventory.ownedEngineIndices.includes(index)) {
    showMessage("Этот двигатель пока не куплен.");
    return;
  }
  state.build.engine = clamp(index, 0, engineModules.length - 1);
  applyBuild(true);
  saveGame();
  showMessage("Двигатель: " + state.currentEngine.name);
}

function setWeapon(typeIndex) {
  if (!canModifyShip()) {
    showMessage("Менять оружие можно только в зачищенной системе.");
    return;
  }
  if (!state.inventory.ownedWeaponIndices.includes(typeIndex)) {
    showMessage("Это оружие пока не получено.");
    return;
  }
  state.build.weapon = typeIndex;
  applyBuild(true);
  saveGame();
  showMessage("Оружие: " + weaponTypes[typeIndex].name);
}

function unlockRandomHull() {
  const inv = state.inventory;
  const owned = new Set(inv.ownedHullIndices);
  const candidates = [];
  for (let i = 0; i < hullTypes.length; i++) {
    if (!owned.has(i)) candidates.push(i);
  }
  if (!candidates.length) return;
  const idx = candidates[Math.floor(Math.random() * candidates.length)];
  inv.ownedHullIndices.push(idx);
  showMessage("Открыт новый корабль: " + hullTypes[idx].name);
}

function unlockRandomWeapon() {
  const inv = state.inventory;
  const owned = new Set(inv.ownedWeaponIndices);
  const candidates = [];
  for (let i = 0; i < weaponTypes.length; i++) {
    if (!owned.has(i)) candidates.push(i);
  }
  if (!candidates.length) return;
  const idx = candidates[Math.floor(Math.random() * candidates.length)];
  inv.ownedWeaponIndices.push(idx);
  showMessage("Получено новое оружие: " + weaponTypes[idx].name);
}

function spawnParticle(x, y, vx, vy, life, color, size) {
  state.particles.push({
    x, y, vx, vy, life,
    maxLife: life,
    color,
    size: size || 2 + Math.random() * 2
  });
}

function spawnExplosion(x, y, count) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * TAU;
    const speed = 60 + Math.random() * 260;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    const life = 0.4 + Math.random() * 0.8;
    const color = "rgba(255,200,120,0.9)";
    spawnParticle(x, y, vx, vy, life, color, 2 + Math.random() * 3);
  }
}

function generateTradeForBase(rng, diff) {
  const trade = {
    hullOffers: [],
    weaponOffers: [],
    engineOffers: [],
    buyModifier: 0.4 + Math.min(0.2, diff * 0.02)
  };

  const hullOfferCount = randInt(rng, 1, 3);
  for (let i = 0; i < hullOfferCount; i++) {
    const hullIndex = randInt(rng, 0, hullTypes.length - 1);
    const hull = hullTypes[hullIndex];
    const price = Math.round(hullPrice(hull) * (0.8 + diff * 0.1));
    trade.hullOffers.push({ hullIndex, price });
  }

  const weaponOfferCount = randInt(rng, 1, 3);
  for (let i = 0; i < weaponOfferCount; i++) {
    const wIndex = randInt(rng, 0, weaponTypes.length - 1);
    const w = weaponTypes[wIndex];
    const price = Math.round(weaponPrice(w) * (0.9 + diff * 0.12));
    trade.weaponOffers.push({ weaponIndex: wIndex, price });
  }

  const engineOfferCount = randInt(rng, 1, engineModules.length);
  for (let i = 0; i < engineOfferCount; i++) {
    const eIndex = clamp(i, 0, engineModules.length - 1);
    const e = engineModules[eIndex];
    const price = Math.round(enginePrice(e) * (0.9 + diff * 0.1));
    trade.engineOffers.push({ engineIndex: eIndex, price });
  }

  return trade;
}

function generateSystem(sx, sy) {
  const seedBase = 987654321;
  const seed = (seedBase ^ (sx * 374761393) ^ (sy * 668265263)) >>> 0;
  const rng = mulberry32(seed);

  const diff = systemDifficulty(sx, sy);
  const isHome = (sx === 0 && sy === 0);

  const starRadius = randRange(rng, 45, 80);
  const starHue = Math.floor(randRange(rng, 0, 360));
  const star = {
    x: 0,
    y: 0,
    radius: starRadius,
    color: "hsl(" + starHue + ", 80%, 60%)"
  };

  const planets = [];
  const bases = [];
  const baseCountMin = 4 + Math.floor(diff * 0.3);
  const baseCountMax = 6 + Math.floor(diff * 0.9);
  const planetCount = clamp(randInt(rng, baseCountMin, baseCountMax), 3, 14);

  let baseOrbit = starRadius + 200;

  for (let i = 0; i < planetCount; i++) {
    const orbitRadius = baseOrbit + randRange(rng, 90, 180);
    baseOrbit = orbitRadius;
    const size = randRange(rng, 14, 34);
    const angle = randRange(rng, 0, TAU);
    let speed = randRange(rng, 0.02, 0.09);
    if (rng() < 0.5) speed *= -1;
    const color = "hsl(" +
      Math.floor(randRange(rng, 0, 360)) +
      ", 50%, " +
      Math.floor(randRange(rng, 40, 70)) + "%)";

    const moons = [];
    if (rng() < 0.85) {
      const moonCount = randInt(rng, 1, 3);
      for (let m = 0; m < moonCount; m++) {
        const mDist = size + randRange(rng, 22, 48) + m * 5;
        const mSize = randRange(rng, 3, 8);
        let mSpeed = speed * randRange(rng, 1.6, 3.8);
        if (rng() < 0.5) mSpeed *= -1;
        const mOffset = randRange(rng, 0, TAU);
        moons.push({
          dist: mDist,
          size: mSize,
          speed: mSpeed,
          offset: mOffset,
          color: "#cccccc",
          x: 0,
          y: 0
        });
      }
    }

    const planet = {
      orbitRadius,
      size,
      angle,
      speed,
      color,
      moons,
      x: 0,
      y: 0
    };
    planets.push(planet);
    const planetIndex = planets.length - 1;

    const baseChanceRaw = 0.25 + diff * 0.08;
    const baseChance = clamp(baseChanceRaw, 0.25, 0.9);
    if (rng() < baseChance) {
      const baseSize = size * randRange(rng, 1.4, 2.0);

      const base = {
        planetIndex,
        size: baseSize,
        hp: 1,
        maxHp: 1,
        alive: true,
        shieldActive: false,
        turrets: [],
        isPeaceful: false,
        trade: null,
        x: 0,
        y: 0
      };

      const distHome = distanceFromHome(sx, sy);
      const peacefulChance = isHome ? 1 : clamp(0.4 + Math.max(0, (2 - distHome) * 0.15), 0.2, 0.9);
      const isPeaceful = (rng() < peacefulChance);
      base.isPeaceful = isPeaceful;

      if (isPeaceful) {
        const hpBase = 180 * (1 + diff * 0.4);
        base.hp = base.maxHp = hpBase;
        base.shieldActive = false;
        base.trade = generateTradeForBase(rng, diff);
      } else {
        const baseHp = 55 * diff * randRange(rng, 0.9, 1.2);
        base.hp = base.maxHp = baseHp;
        base.shieldActive = true;

        const turretCount = clamp(randInt(rng, 2, 3 + Math.floor(diff * 0.4)), 1, 6);
        const turrets = [];
        for (let t = 0; t < turretCount; t++) {
          const tHpBase = 3 + Math.floor(diff * 0.8);
          turrets.push({
            offsetAngle: (TAU / turretCount) * t,
            orbitRadius: baseSize + 26,
            fireCooldown: randRange(rng, 0.5, 2.0),
            alive: true,
            hp: tHpBase,
            worldX: 0,
            worldY: 0
          });
        }
        base.turrets = turrets;
      }

      bases.push(base);
    }
  }

  const bgStars = [];
  const bgCount = 260;
  for (let i = 0; i < bgCount; i++) {
    bgStars.push({
      x: randRange(rng, -4500, 4500),
      y: randRange(rng, -4500, 4500),
      r: randRange(rng, 0.4, 1.6),
      alpha: randRange(rng, 0.15, 0.85)
    });
  }

  const enemies = [];
  const outerOrb = planets.length ? planets[planets.length - 1].orbitRadius : starRadius + 700;
  if (!isHome) {
    const enemyCountMin = 2 + Math.floor(diff * 0.8);
    const enemyCountMax = 4 + Math.floor(diff * 1.4);
    const enemyCount = clamp(randInt(rng, enemyCountMin, enemyCountMax), 2, 18);

    for (let i = 0; i < enemyCount; i++) {
      const angle = randRange(rng, 0, TAU);
      const dist = randRange(rng, outerOrb * 0.6, outerOrb * 1.4);
      const x = Math.cos(angle) * dist;
      const y = Math.sin(angle) * dist;
      enemies.push({
        x,
        y,
        vx: 0,
        vy: 0,
        radius: 15,
        hp: 4 + Math.floor(diff * randRange(rng, 0.8, 1.5)),
        alive: true,
        fireCooldown: randRange(rng, 1.0, 3.5)
      });
    }
  }

  const gates = [];
  const outerRadius = planets.length ? planets[planets.length - 1].orbitRadius : starRadius + 600;
  const gateDist = outerRadius + 320;
  const gateRadius = 80;
  gates.push({ x: star.x + gateDist, y: star.y, radius: gateRadius, dx: +1, dy: 0 });
  gates.push({ x: star.x - gateDist, y: star.y, radius: gateRadius, dx: -1, dy: 0 });
  gates.push({ x: star.x, y: star.y + gateDist, radius: gateRadius, dx: 0, dy: +1 });
  gates.push({ x: star.x, y: star.y - gateDist, radius: gateRadius, dx: 0, dy: -1 });

  let quantum = null;
  if (!isHome && rng() < 0.07) {
    const angle = randRange(rng, 0, TAU);
    const distBlack = outerRadius * randRange(rng, 0.3, 0.7);
    const distWhite = outerRadius * randRange(rng, 0.9, 1.4);
    const black = {
      x: star.x + Math.cos(angle) * distBlack,
      y: star.y + Math.sin(angle) * distBlack,
      radius: 70
    };
    const white = {
      x: star.x + Math.cos(angle) * distWhite,
      y: star.y + Math.sin(angle) * distWhite,
      radius: 75
    };
    quantum = { black, white };
  }

  const adjectives = ["Туманность", "Пустота", "Хаос", "Облако", "Вихрь", "Сингулярность"];
  const nouns = ["Эридана", "Гидры", "Андромеды", "Кассиопеи", "Персея", "Центавра", "Кита"];
  const idx = Math.abs(sx * 73856093 ^ sy * 19349663);
  const name = adjectives[idx % adjectives.length] + " " + nouns[(idx >> 3) % nouns.length];

  const loot = [];

  return {
    sx,
    sy,
    difficulty: diff,
    star,
    planets,
    bases,
    bgStars,
    enemies,
    gates,
    quantum,
    loot,
    name,
    clearedNotified: false
  };
}

function updatePlanetsAndMoons(sys, dt) {
  const star = sys.star;
  for (const p of sys.planets) {
    p.angle += p.speed * dt;
    p.x = star.x + Math.cos(p.angle) * p.orbitRadius;
    p.y = star.y + Math.sin(p.angle) * p.orbitRadius;

    for (const m of p.moons) {
      const ang = m.offset + state.time * m.speed;
      m.x = p.x + Math.cos(ang) * m.dist;
      m.y = p.y + Math.sin(ang) * m.dist;
    }
  }
}

function updateBasesAndTurrets(sys, dt) {
  const planets = sys.planets;
  const ship = state.ship;

  for (const base of sys.bases) {
    if (!base.alive) continue;
    const planet = planets[base.planetIndex];
    if (!planet) continue;

    base.x = planet.x;
    base.y = planet.y - planet.size - base.size * 0.5;

    if (base.isPeaceful) continue;

    let aliveTurrets = 0;
    for (const t of base.turrets) {
      if (!t.alive) continue;
      aliveTurrets++;

      const ang = t.offsetAngle + state.time * 0.5;
      t.worldX = base.x + Math.cos(ang) * t.orbitRadius;
      t.worldY = base.y + Math.sin(ang) * t.orbitRadius;

      const dx = ship.x - t.worldX;
      const dy = ship.y - t.worldY;
      const dist = Math.hypot(dx, dy) || 0.0001;

      t.fireCooldown -= dt;
      if (t.fireCooldown <= 0 && dist < 1100) {
        const a = Math.atan2(dy, dx);
        const bulletSpeed = 380 + 25 * (sys.difficulty || 1);
        state.bullets.push({
          x: t.worldX + Math.cos(a) * 8,
          y: t.worldY + Math.sin(a) * 8,
          vx: Math.cos(a) * bulletSpeed,
          vy: Math.sin(a) * bulletSpeed,
          radius: 3,
          life: 2.2,
          hostile: true,
          damage: 12 + 6 * (sys.difficulty || 1),
          color: "#ff7777"
        });
        t.fireCooldown = 1.0 + Math.random() * 0.8;
      }
    }
    const wasShield = base.shieldActive;
    base.shieldActive = aliveTurrets > 0;
    if (wasShield && !base.shieldActive) {
      spawnExplosion(base.x, base.y, 40);
      showMessage("Щит базы отключён");
    }
  }
}

function saveCurrentSystem() {
  if (!state.starSystem) return;
  const key = systemKey(state.systemX, state.systemY);
  galaxyCache[key] = state.starSystem;
}

function saveGame() {
  try {
    saveCurrentSystem();
    const data = {
      version: 4,
      systemX: state.systemX,
      systemY: state.systemY,
      ship: {
        x: state.ship.x,
        y: state.ship.y,
        vx: state.ship.vx,
        vy: state.ship.vy,
        angle: state.ship.angle,
        hp: state.ship.hp
      },
      build: state.build,
      inventory: state.inventory,
      stats: state.playerStats,
      credits: state.credits,
      visited: state.visitedSystems,
      systems: galaxyCache,
      energy: state.energy,
      quests: state.quests
    };
    if (window.localStorage) {
      window.localStorage.setItem(SAVE_KEY, JSON.stringify(data));
    }
    document.cookie = "eh_save=1; path=/; max-age=31536000";
  } catch (e) {
    console.warn("Не удалось сохранить игру:", e);
  }
}

function loadGame() {
  try {
    if (!window.localStorage) return false;
    const raw = window.localStorage.getItem(SAVE_KEY);
    if (!raw) return false;
    const data = JSON.parse(raw);
    if (!data || typeof data.systemX !== "number" || typeof data.systemY !== "number") {
      return false;
    }

    state.systemX = data.systemX;
    state.systemY = data.systemY;

    galaxyCache = data.systems || {};
    state.build = data.build || state.build;
    state.inventory = data.inventory || state.inventory;
    state.playerStats = data.stats || state.playerStats;
    state.credits = data.credits || 0;
    state.visitedSystems = data.visited || {};
    state.energy = data.energy || { current: 100, max: 100, regen: 3 };
    state.quests = data.quests || createDefaultQuests();

    const key = systemKey(state.systemX, state.systemY);
    let sys = galaxyCache[key];
    if (!sys) {
      sys = generateSystem(state.systemX, state.systemY);
      galaxyCache[key] = sys;
    }
    state.starSystem = sys;
    state.enemies = sys.enemies;
    state.loot = sys.loot || (sys.loot = []);

    const shipData = data.ship || {};
    const ship = state.ship;
    ship.x = typeof shipData.x === "number" ? shipData.x : 0;
    ship.y = typeof shipData.y === "number" ? shipData.y : -(sys.star.radius + 320);
    ship.vx = shipData.vx || 0;
    ship.vy = shipData.vy || 0;
    ship.angle = typeof shipData.angle === "number" ? shipData.angle : Math.PI / 2;
    ship.hp = typeof shipData.hp === "number" ? shipData.hp : ship.maxHp;

    applyBuild(true);
    markVisited(state.systemX, state.systemY);
    return true;
  } catch (e) {
    console.warn("Не удалось загрузить игру:", e);
    return false;
  }
}

function resetGame() {
  try {
    if (window.localStorage) {
      window.localStorage.removeItem(SAVE_KEY);
    }
  } catch (e) {}
  galaxyCache = {};
  state.systemX = 0;
  state.systemY = 0;
  state.ship.x = 0;
  state.ship.y = 0;
  state.ship.vx = 0;
  state.ship.vy = 0;
  state.ship.angle = Math.PI / 2;
  state.playerStats = {
    level: 1,
    xp: 0,
    xpToNext: 80,
    upgradePoints: 0,
    upgrades: {
      damage: 0,
      reload: 0,
      hp: 0,
      speed: 0,
      regen: 0,
      energy: 0
    }
  };
  state.inventory = {
    ownedHullIndices: [0, 1, 2, 3, 4],
    activeHullIndex: 0,
    ownedWeaponIndices: [0, 1, 2],
    ownedEngineIndices: [0, 1, 2]
  };
  state.build = { engine: 0, weapon: 0 };
  state.credits = 0;
  state.visitedSystems = {};
  state.energy = { current: 100, max: 100, regen: 3 };
  state.quests = createDefaultQuests();
  state.ui.paused = false;
  state.ui.mapOpen = false;
  applyBuild(false);
  enterSystem(0, 0, 0, 0);
  showMessage("Прогресс сброшен.");
}

function markVisited(sx, sy) {
  state.visitedSystems[systemKey(sx, sy)] = true;
}

function enterSystem(newX, newY, fromDx, fromDy) {
  saveCurrentSystem();

  state.systemX = newX;
  state.systemY = newY;

  const key = systemKey(newX, newY);
  let sys = galaxyCache[key];
  if (!sys) {
    sys = generateSystem(newX, newY);
    galaxyCache[key] = sys;
  }
  state.starSystem = sys;
  state.enemies = sys.enemies;
  state.loot = sys.loot || (sys.loot = []);
  state.bullets.length = 0;
  state.particles.length = 0;
  state.gateCooldown = 1.0;

  const ship = state.ship;
  const star = sys.star;

  let spawnX = star.x;
  let spawnY = star.y - (star.radius + 320);

  if (fromDx || fromDy) {
    const gate = sys.gates.find(g => g.dx === fromDx && g.dy === fromDy);
    if (gate) {
      const offset = 140;
      spawnX = gate.x + fromDx * offset;
      spawnY = gate.y + fromDy * offset;
    }
  }

  ship.x = spawnX;
  ship.y = spawnY;
  ship.vx = 0;
  ship.vy = 0;
  ship.angle = Math.PI / 2;

  spawnExplosion(ship.x, ship.y, 60);
  markVisited(newX, newY);
  saveGame();
}

function dropLoot(x, y, diff, big) {
  const amount = Math.round((10 + Math.random() * 25) * diff * (big ? 2 : 1));
  const loot = {
    x,
    y,
    vx: (Math.random() - 0.5) * 40,
    vy: (Math.random() - 0.5) * 40,
    radius: 7,
    amount,
    t: 0
  };
  state.loot.push(loot);
}

function collectLoot(loot) {
  let amount = loot.amount;
  const hull = state.currentHull;
  if (hull && hull.abilityType === "loot") {
    amount = Math.round(amount * (1 + hull.abilityPower));
  }
  state.credits += amount;
  spawnExplosion(loot.x, loot.y, 10);
  showMessage("Поднят лут: +" + amount + " кредитов");
  if (Math.random() < 0.15) {
    unlockRandomHull();
  } else if (Math.random() < 0.12) {
    unlockRandomWeapon();
  }
}

function damageShip(amount) {
  const ship = state.ship;
  ship.hp -= amount;
  if (ship.hp <= 0) {
    ship.hp = 0;
    spawnExplosion(ship.x, ship.y, 100);
    const sys = state.starSystem;
    if (sys) {
      const star = sys.star;
      const radius = star.radius + 320;
      ship.x = star.x + radius;
      ship.y = star.y;
    } else {
      ship.x = 0;
      ship.y = 0;
    }
    ship.vx = 0;
    ship.vy = 0;
    ship.angle = Math.PI;
    ship.hp = ship.maxHp;
    spawnExplosion(ship.x, ship.y, 60);
    saveGame();
    showMessage("Корабль уничтожен, выполнен аварийный респаун.");
  }
}

function killEnemy(e) {
  if (!e.alive) return;
  const sys = state.starSystem;
  const diff = sys ? (sys.difficulty || 1) : 1;
  e.alive = false;
  spawnExplosion(e.x, e.y, 25);
  addXp(12 * diff);
  dropLoot(e.x, e.y, diff, false);
}

function hitEnemy(e, damage) {
  e.hp -= damage;
  spawnExplosion(e.x, e.y, 4);
  if (e.hp <= 0 && e.alive) {
    killEnemy(e);
  }
}

function hitBase(base, damage) {
  if (!base.alive) return;
  if (base.isPeaceful) return;

  const sys = state.starSystem;
  const diff = sys ? (sys.difficulty || 1) : 1;
  const realDamage = base.shieldActive ? damage * 0.15 : damage;
  base.hp -= realDamage;
  spawnExplosion(base.x, base.y, 6);
  if (base.hp <= 0 && base.alive) {
    base.hp = 0;
    base.alive = false;
    spawnExplosion(base.x, base.y, 80);
    for (const t of base.turrets) {
      if (t.alive) {
        t.alive = false;
        spawnExplosion(t.worldX, t.worldY, 10);
      }
    }
    addXp(45 * diff);
    dropLoot(base.x, base.y, diff, true);
    unlockRandomHull();
    saveGame();
    showMessage("Боевой форпост уничтожен.");
  }
}

function startHyperJump(gate) {
  state.hyperJump.active = true;
  state.hyperJump.t = 0;
  state.hyperJump.fromX = state.systemX;
  state.hyperJump.fromY = state.systemY;
  state.hyperJump.toX = state.systemX + gate.dx;
  state.hyperJump.toY = state.systemY + gate.dy;
  state.hyperJump.dirX = gate.dx;
  state.hyperJump.dirY = gate.dy;
  state.hyperJump.mode = "gate";
  state.gateCooldown = 2.0;
}

function startMapJump(targetX, targetY) {
  if (targetX === state.systemX && targetY === state.systemY) return;
  const key = systemKey(targetX, targetY);
  if (!state.visitedSystems[key]) {
    showMessage("Можно прыгать только в посещённые системы.");
    return;
  }
  const dx = targetX - state.systemX;
  const dy = targetY - state.systemY;
  const dist = Math.hypot(dx, dy);
  const baseCost = 25;
  const perUnit = 18;
  const cost = Math.ceil(baseCost + perUnit * dist);
  if (state.energy.current < cost) {
    showMessage("Недостаточно энергии для прыжка (нужно " + cost + ").");
    return;
  }
  state.energy.current -= cost;

  state.hyperJump.active = true;
  state.hyperJump.t = 0;
  state.hyperJump.fromX = state.systemX;
  state.hyperJump.fromY = state.systemY;
  state.hyperJump.toX = targetX;
  state.hyperJump.toY = targetY;
  state.hyperJump.dirX = dx === 0 ? 0 : (dx > 0 ? 1 : -1);
  state.hyperJump.dirY = dy === 0 ? 0 : (dy > 0 ? 1 : -1);
  state.hyperJump.mode = "map";
  state.ui.mapOpen = false;
  showMessage("Гиперпрыжок по карте – расход энергии " + cost + ".");
}

function finishHyperJump() {
  const hj = state.hyperJump;
  hj.active = false;
  if (hj.mode === "map") {
    enterSystem(hj.toX, hj.toY, 0, 0);
  } else {
    enterSystem(hj.toX, hj.toY, -hj.dirX, -hj.dirY);
  }
}

function onSystemCleared(sx, sy, diff) {
  const quests = state.quests;
  if (!quests) return;
  for (let i = quests.active.length - 1; i >= 0; i--) {
    const q = quests.active[i];
    if (q.type === "clearSystem" && !q.completed &&
        q.targetX === sx && q.targetY === sy) {
      q.completed = true;
      quests.active.splice(i, 1);
      quests.completed.push(q);
      const credits = q.rewardCredits || 0;
      const xp = q.rewardXp || 0;
      state.credits += credits;
      addXp(xp);
      showMessage("Квест выполнен: " + q.title +
        " (+" + credits + " кр, +" + xp + " XP)");
    }
  }
  saveGame();
}

function onKeyDown(e) {
  const code = e.code;

  if (code === "KeyM") {
    if (state.ui.paused) return;
    state.ui.mapOpen = !state.ui.mapOpen;
    if (state.ui.mapOpen) {
      state.ui.mapCenterX = state.systemX;
      state.ui.mapCenterY = state.systemY;
    }
    return;
  }

  if (code === "KeyE") {
    if (state.ui.mapOpen) return;
    state.ui.paused = !state.ui.paused;
    state.ui.tab = "main";
    return;
  }

  if (code === "KeyQ") {
    if (state.ui.mapOpen) {
      state.ui.mapOpen = false;
      return;
    }
    if (state.ui.paused) {
      if (state.ui.tab !== "main") {
        state.ui.tab = "main";
      } else {
        state.ui.paused = false;
      }
      return;
    }
    return;
  }

  if (state.ui.mapOpen) return;

  if (state.ui.paused) {
    if (code === "KeyZ") spendUpgrade("damage");
    else if (code === "KeyX") spendUpgrade("reload");
    else if (code === "KeyC") spendUpgrade("hp");
    else if (code === "KeyV") spendUpgrade("speed");
    else if (code === "KeyB") spendUpgrade("regen");
    else if (code === "KeyN") spendUpgrade("energy");
    return;
  }

  switch (code) {
    case "KeyZ":
      spendUpgrade("damage");
      break;
    case "KeyX":
      spendUpgrade("reload");
      break;
    case "KeyC":
      spendUpgrade("hp");
      break;
    case "KeyV":
      spendUpgrade("speed");
      break;
    case "KeyB":
      spendUpgrade("regen");
      break;
    case "KeyN":
      spendUpgrade("energy");
      break;
    case "ArrowLeft":
    case "KeyA":
      cycleHull(-1);
      break;
    case "ArrowRight":
    case "KeyD":
      cycleHull(+1);
      break;
    case "Digit4":
      setEngine(0);
      break;
    case "Digit5":
      setEngine(1);
      break;
    case "Digit6":
      setEngine(2);
      break;
    case "Digit7":
      setWeapon(0);
      break;
    case "Digit8":
      setWeapon(1);
      break;
    case "Digit9":
      setWeapon(2);
      break;
    default:
      break;
  }
}

function isSystemCleared(sys) {
  if (!sys) return false;
  const enemiesAlive = state.enemies.some(e => e.alive);
  const hostileBasesAlive = sys.bases.some(b => b.alive && !b.isPeaceful);
  if (state.systemX === 0 && state.systemY === 0) return true;
  return !enemiesAlive && !hostileBasesAlive;
}

let lastTime = performance.now();

function update(dt) {
  state.time += dt;

  const energy = state.energy;
  if (energy) {
    energy.current = Math.min(energy.max, energy.current + energy.regen * dt);
  }

  if (state.messageTimer > 0) {
    state.messageTimer -= dt;
    if (state.messageTimer <= 0) {
      state.messageTimer = 0;
      state.message = "";
    }
  }

  const sys = state.starSystem;
  if (!sys) return;

  if (state.hyperJump.active) {
    state.hyperJump.t += dt;
    if (state.hyperJump.t >= state.hyperJump.duration) {
      finishHyperJump();
    }
    return;
  }

  if (state.ui.mapOpen || state.ui.paused) {
    return;
  }

  const ship = state.ship;
  state.gateCooldown = Math.max(0, state.gateCooldown - dt);

  mouse.worldX = ship.x + (mouse.x - canvas.width / 2);
  mouse.worldY = ship.y + (mouse.y - canvas.height / 2);

  if (mouse.down) {
    const targetAngle = Math.atan2(mouse.worldY - ship.y, mouse.worldX - ship.x);
    let diff = normalizeAngle(targetAngle - ship.angle);
    const maxTurn = 7.0 * dt;
    if (diff > maxTurn) diff = maxTurn;
    if (diff < -maxTurn) diff = -maxTurn;
    ship.angle += diff;
  }

  const forward = keys["KeyW"] || keys["ArrowUp"];
  const backward = keys["KeyS"] || keys["ArrowDown"];
  const boost = keys["ShiftLeft"] || keys["ShiftRight"];
  const thrustPower = ship.thrust * (boost ? 1.6 : 1.0);

  if (forward) {
    ship.vx += Math.cos(ship.angle) * thrustPower * dt;
    ship.vy += Math.sin(ship.angle) * thrustPower * dt;

    const ex = ship.x - Math.cos(ship.angle) * ship.radius * 0.8;
    const ey = ship.y - Math.sin(ship.angle) * ship.radius * 0.8;
    const spread = 50;
    spawnParticle(
      ex,
      ey,
      ship.vx + (Math.random() - 0.5) * spread,
      ship.vy + (Math.random() - 0.5) * spread,
      0.25 + Math.random() * 0.25,
      "rgba(255,200,100,0.9)",
      2 + Math.random() * 2
    );
  }

  if (backward) {
    ship.vx -= Math.cos(ship.angle) * ship.thrust * 0.6 * dt;
    ship.vy -= Math.sin(ship.angle) * ship.thrust * 0.6 * dt;
  }

  const speed = Math.hypot(ship.vx, ship.vy);
  if (speed > ship.maxSpeed) {
    const s = ship.maxSpeed / speed;
    ship.vx *= s;
    ship.vy *= s;
  }

  ship.vx *= ship.friction;
  ship.vy *= ship.friction;

  ship.x += ship.vx * dt;
  ship.y += ship.vy * dt;

  if (ship.regen > 0 && ship.hp > 0) {
    ship.hp = Math.min(ship.maxHp, ship.hp + ship.regen * dt);
  }

  updatePlanetsAndMoons(sys, dt);
  updateBasesAndTurrets(sys, dt);

  const star = sys.star;
  const dxs = ship.x - star.x;
  const dys = ship.y - star.y;
  const distStar = Math.hypot(dxs, dys);
  const minStarDist = star.radius + ship.radius * 0.7;
  if (distStar < minStarDist) {
    const overlap = minStarDist - distStar;
    const nx = dxs / (distStar || 0.0001);
    const ny = dys / (distStar || 0.0001);
    ship.x += nx * overlap * 0.6;
    ship.y += ny * overlap * 0.6;
    damageShip(35 * dt * (sys.difficulty || 1));
  }

  if (sys.quantum) {
    const q = sys.quantum;
    const b = q.black;
    const wq = q.white;

    const dxB = ship.x - b.x;
    const dyB = ship.y - b.y;
    const distB = Math.hypot(dxB, dyB);
    if (distB < b.radius * 3) {
      const nx = dxB / (distB || 0.0001);
      const ny = dyB / (distB || 0.0001);
      const strength = (b.radius * 3 - distB) * 0.7;
      ship.vx -= nx * strength * dt;
      ship.vy -= ny * strength * dt;
    }
    if (distB < b.radius * 0.6) {
      ship.x = wq.x + (Math.random() - 0.5) * wq.radius * 0.5;
      ship.y = wq.y + (Math.random() - 0.5) * wq.radius * 0.5;
      spawnExplosion(ship.x, ship.y, 50);
    }

    const dxW = ship.x - wq.x;
    const dyW = ship.y - wq.y;
    const distW = Math.hypot(dxW, dyW);
    if (distW < wq.radius * 3) {
      const nx = dxW / (distW || 0.0001);
      const ny = dyW / (distW || 0.0001);
      const strength = (wq.radius * 3 - distW) * 0.8;
      ship.vx += nx * strength * dt;
      ship.vy += ny * strength * dt;
    }
  }

  ship.fireCooldown = Math.max(0, ship.fireCooldown - dt);
  const wantFire = keys["Space"];
  if (wantFire && ship.fireCooldown <= 0) {
    const weapon = state.currentWeapon;
    if (weapon) {
      const baseAngle = ship.angle;
      for (let i = 0; i < weapon.projectiles; i++) {
        const spreadAngle = (Math.random() - 0.5) * weapon.spread;
        const angle = baseAngle + spreadAngle;
        const bx = ship.x + Math.cos(angle) * ship.radius * 1.4;
        const by = ship.y + Math.sin(angle) * ship.radius * 1.4;
        const bVx = ship.vx + Math.cos(angle) * weapon.bulletSpeed;
        const bVy = ship.vy + Math.sin(angle) * weapon.bulletSpeed;
        state.bullets.push({
          x: bx,
          y: by,
          vx: bVx,
          vy: bVy,
          radius: 3,
          life: 1.6,
          hostile: false,
          damage: weapon.damage,
          color: weapon.color,
          explosiveRadius: weapon.explosiveRadius || 0
        });
      }
      ship.fireCooldown = weapon.cooldown;
    }
  }

  const hull = state.currentHull;
  const hasAura = hull && hull.abilityType === "aura";
  const auraPower = hasAura ? hull.abilityPower : 0;
  const auraRadius = hasAura ? 280 : 0;

  for (let i = state.enemies.length - 1; i >= 0; i--) {
    const e = state.enemies[i];
    if (!e.alive) {
      state.enemies.splice(i, 1);
      continue;
    }

    const dx = ship.x - e.x;
    const dy = ship.y - e.y;
    const dist = Math.hypot(dx, dy) || 0.0001;

    const targetSpeed = 140 + 15 * (sys.difficulty || 1);
    const desiredVX = (dx / dist) * targetSpeed;
    const desiredVY = (dy / dist) * targetSpeed;

    e.vx += (desiredVX - e.vx) * 0.6 * dt;
    e.vy += (desiredVY - e.vy) * 0.6 * dt;

    e.x += e.vx * dt;
    e.y += e.vy * dt;

    const minDist = e.radius + ship.radius;
    if (dist < minDist) {
      const overlap = minDist - dist;
      const nx = dx / dist;
      const ny = dy / dist;
      e.x -= nx * overlap * 0.5;
      e.y -= ny * overlap * 0.5;
      ship.x += nx * overlap * 0.5;
      ship.y += ny * overlap * 0.5;
      damageShip(18 * dt * (sys.difficulty || 1));
    }

    if (hasAura && dist < auraRadius) {
      e.hp -= auraPower * dt;
      if (e.hp <= 0 && e.alive) {
        killEnemy(e);
        continue;
      }
    }

    e.fireCooldown -= dt;
    if (e.fireCooldown <= 0 && dist < 900) {
      const angleToShip = Math.atan2(dy, dx);
      const bulletSpeed = 420 + 30 * (sys.difficulty || 1);
      state.bullets.push({
        x: e.x + Math.cos(angleToShip) * e.radius,
        y: e.y + Math.sin(angleToShip) * e.radius,
        vx: Math.cos(angleToShip) * bulletSpeed,
        vy: Math.sin(angleToShip) * bulletSpeed,
        radius: 3,
        life: 2.0,
        hostile: true,
        damage: 16 + 4 * (sys.difficulty || 1),
        color: "#ff5555"
      });
      e.fireCooldown = 1.6 + Math.random() * 1.6;
    }
  }

  for (let i = state.bullets.length - 1; i >= 0; i--) {
    const b = state.bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.life -= dt;
    let remove = false;

    if (b.hostile) {
      const dx = ship.x - b.x;
      const dy = ship.y - b.y;
      const dist = Math.hypot(dx, dy);
      if (dist < ship.radius + b.radius) {
        damageShip(b.damage || 15);
        remove = true;
      }
    } else {
      for (let j = state.enemies.length - 1; j >= 0; j--) {
        const e = state.enemies[j];
        if (!e.alive) continue;
        const dx = e.x - b.x;
        const dy = e.y - b.y;
        const dist = Math.hypot(dx, dy);
        if (dist < e.radius + b.radius) {
          if (b.explosiveRadius && b.explosiveRadius > 0) {
            for (const e2 of state.enemies) {
              if (!e2.alive) continue;
              const ddx = e2.x - b.x;
              const ddy = e2.y - b.y;
              const d2 = Math.hypot(ddx, ddy);
              if (d2 < b.explosiveRadius) {
                hitEnemy(e2, (b.damage || 1));
              }
            }
          } else {
            hitEnemy(e, b.damage || 1);
          }
          remove = true;
          break;
        }
      }
      if (!remove) {
        for (const base of sys.bases) {
          if (!base.alive || base.isPeaceful) continue;
          for (const t of base.turrets) {
            if (!t.alive) continue;
            const dx = t.worldX - b.x;
            const dy = t.worldY - b.y;
            const dist = Math.hypot(dx, dy);
            const turretRadius = 9;
            if (dist < turretRadius + b.radius) {
              t.hp -= (b.damage || 1);
              spawnExplosion(t.worldX, t.worldY, 4);
              if (t.hp <= 0 && t.alive) {
                t.alive = false;
                spawnExplosion(t.worldX, t.worldY, 18);
              }
              remove = true;
              break;
            }
          }
          if (remove) break;
        }
      }
      if (!remove) {
        for (const base of sys.bases) {
          if (!base.alive || base.isPeaceful) continue;
          const dx = base.x - b.x;
          const dy = base.y - b.y;
          const dist = Math.hypot(dx, dy);
          if (dist < base.size + b.radius) {
            hitBase(base, b.damage || 1);
            remove = true;
            break;
          }
        }
      }
    }

    if (remove || b.life <= 0) {
      state.bullets.splice(i, 1);
    }
  }

  for (let i = state.loot.length - 1; i >= 0; i--) {
    const l = state.loot[i];
    l.t += dt;
    l.x += l.vx * dt;
    l.y += l.vy * dt;
    l.vx *= 0.98;
    l.vy *= 0.98;

    const dx = ship.x - l.x;
    const dy = ship.y - l.y;
    const dist = Math.hypot(dx, dy);
    if (dist < ship.radius + l.radius + 4) {
      collectLoot(l);
      state.loot.splice(i, 1);
    }
  }

  for (let i = state.particles.length - 1; i >= 0; i--) {
    const p = state.particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= dt;
    if (p.life <= 0) {
      state.particles.splice(i, 1);
    }
  }

  for (const gate of sys.gates) {
    const dx = ship.x - gate.x;
    const dy = ship.y - gate.y;
    const dist = Math.hypot(dx, dy);
    if (dist < gate.radius * 0.7 && state.gateCooldown <= 0) {
      startHyperJump(gate);
      return;
    }
  }

  if (sys && !sys.clearedNotified && isSystemCleared(sys)) {
    sys.clearedNotified = true;
    onSystemCleared(sys.sx, sys.sy, sys.difficulty || 1);
  }
}

function drawShipIcon(x, y, angle, size, fill, shape) {
  const color = fill || "#66d9ff";
  const s = shape || "arrow";
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.fillStyle = color;
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 2;

  ctx.beginPath();
  if (s === "disk") {
    ctx.arc(0, 0, size, 0, TAU);
    ctx.moveTo(size * 0.5, 0);
    ctx.arc(0, 0, size * 0.5, 0, TAU);
  } else if (s === "hammer") {
    ctx.rect(-size * 0.2, -size * 0.4, size * 1.0, size * 0.8);
    ctx.moveTo(-size * 0.2, -size * 0.7);
    ctx.lineTo(-size * 0.2, size * 0.7);
    ctx.lineTo(-size * 0.9, size * 0.7);
    ctx.lineTo(-size * 0.9, -size * 0.7);
    ctx.closePath();
  } else if (s === "delta") {
    ctx.moveTo(size, 0);
    ctx.lineTo(-size * 0.6, size * 0.8);
    ctx.lineTo(-size * 0.6, -size * 0.8);
    ctx.closePath();
  } else if (s === "spear") {
    ctx.moveTo(size, 0);
    ctx.lineTo(-size * 0.8, size * 0.3);
    ctx.lineTo(-size * 0.4, 0);
    ctx.lineTo(-size * 0.8, -size * 0.3);
    ctx.closePath();
  } else {
    ctx.moveTo(size, 0);
    ctx.lineTo(-size * 0.8, size * 0.6);
    ctx.lineTo(-size * 0.4, 0);
    ctx.lineTo(-size * 0.8, -size * 0.6);
    ctx.closePath();
  }

  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function draw() {
  const w = canvas.width;
  const h = canvas.height;
  ctx.clearRect(0, 0, w, h);

  const sys = state.starSystem;
  if (!sys) return;

  const ship = state.ship;
  const camX = ship.x;
  const camY = ship.y;

  function worldToScreen(wx, wy) {
    return {
      x: w / 2 + (wx - camX),
      y: h / 2 + (wy - camY)
    };
  }

  if (state.hyperJump.active) {
    drawHyperJumpScene();
    drawHUD(true);
    return;
  }

  for (const s of sys.bgStars) {
    const sx = w / 2 + (s.x - camX * 0.15);
    const sy = h / 2 + (s.y - camY * 0.15);
    if (sx < -5 || sy < -5 || sx > w + 5 || sy > h + 5) continue;
    ctx.globalAlpha = s.alpha;
    ctx.beginPath();
    ctx.arc(sx, sy, s.r, 0, TAU);
    ctx.fillStyle = "#ffffff";
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  const star = sys.star;
  const starScreen = worldToScreen(star.x, star.y);

  for (const p of sys.planets) {
    const sCenter = worldToScreen(star.x, star.y);
    ctx.beginPath();
    ctx.strokeStyle = "rgba(255,255,255,0.05)";
    ctx.lineWidth = 1;
    ctx.arc(sCenter.x, sCenter.y, p.orbitRadius, 0, TAU);
    ctx.stroke();
  }

  for (const gate of sys.gates) {
    const gs = worldToScreen(gate.x, gate.y);
    const pulse = 1 + 0.1 * Math.sin(state.time * 4);
    ctx.save();
    ctx.translate(gs.x, gs.y);
    ctx.beginPath();
    ctx.lineWidth = 4;
    ctx.strokeStyle =
      gate.dx > 0 ? "#66ffd5" :
      gate.dx < 0 ? "#ff77ff" :
      gate.dy > 0 ? "#77ff77" : "#ff9966";
    ctx.arc(0, 0, gate.radius * pulse, 0, TAU);
    ctx.stroke();

    ctx.beginPath();
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = "rgba(255,255,255,0.5)";
    ctx.arc(0, 0, gate.radius * 0.6, 0, TAU);
    ctx.stroke();
    ctx.restore();

    ctx.font = "12px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    const targetX = state.systemX + gate.dx;
    const targetY = state.systemY + gate.dy;
    ctx.fillText(
      "→ [" + targetX + ", " + targetY + "]",
      gs.x,
      gs.y + gate.radius + 6
    );
  }

  if (sys.quantum) {
    const b = sys.quantum.black;
    const wq = sys.quantum.white;

    let pos = worldToScreen(b.x, b.y);
    const gradB = ctx.createRadialGradient(
      pos.x, pos.y, 0,
      pos.x, pos.y, b.radius
    );
    gradB.addColorStop(0, "#000000");
    gradB.addColorStop(0.3, "#000000");
    gradB.addColorStop(0.7, "#552244");
    gradB.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = gradB;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, b.radius, 0, TAU);
    ctx.fill();

    pos = worldToScreen(wq.x, wq.y);
    const gradW = ctx.createRadialGradient(
      pos.x, pos.y, 0,
      pos.x, pos.y, wq.radius
    );
    gradW.addColorStop(0, "#ffffff");
    gradW.addColorStop(0.4, "#ffffcc");
    gradW.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = gradW;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, wq.radius, 0, TAU);
    ctx.fill();
  }

  const grad = ctx.createRadialGradient(
    starScreen.x, starScreen.y, 0,
    starScreen.x, starScreen.y, star.radius * 1.5
  );
  grad.addColorStop(0, "#ffffff");
  grad.addColorStop(0.4, star.color);
  grad.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(starScreen.x, starScreen.y, star.radius * 1.5, 0, TAU);
  ctx.fill();

  ctx.fillStyle = star.color;
  ctx.beginPath();
  ctx.arc(starScreen.x, starScreen.y, star.radius * 0.85, 0, TAU);
  ctx.fill();

  for (const p of sys.planets) {
    const ps = worldToScreen(p.x, p.y);
    const gradP = ctx.createRadialGradient(
      ps.x - p.size * 0.5, ps.y - p.size * 0.5, p.size * 0.1,
      ps.x, ps.y, p.size * 1.4
    );
    gradP.addColorStop(0, "#ffffff");
    gradP.addColorStop(0.3, p.color);
    gradP.addColorStop(1, "#000000");
    ctx.fillStyle = gradP;
    ctx.beginPath();
    ctx.arc(ps.x, ps.y, p.size, 0, TAU);
    ctx.fill();

    for (const m of p.moons) {
      const ms = worldToScreen(m.x, m.y);
      ctx.beginPath();
      ctx.arc(ms.x, ms.y, m.size, 0, TAU);
      ctx.fillStyle = m.color;
      ctx.fill();
    }
  }

  for (const base of sys.bases) {
    if (!base.alive) continue;
    const bs = worldToScreen(base.x, base.y);

    if (base.shieldActive && !base.isPeaceful) {
      const alpha = 0.25 + 0.15 * Math.sin(state.time * 5);
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(bs.x, bs.y, base.size + 14, 0, TAU);
      ctx.strokeStyle = "#88aaff";
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.save();
    ctx.translate(bs.x, bs.y);
    ctx.rotate(state.time * 0.25);
    ctx.beginPath();
    const r = base.size;
    ctx.moveTo(r, 0);
    ctx.lineTo(r * 0.3, r * 0.9);
    ctx.lineTo(-r * 0.3, r * 0.9);
    ctx.lineTo(-r, 0);
    ctx.lineTo(-r * 0.3, -r * 0.9);
    ctx.lineTo(r * 0.3, -r * 0.9);
    ctx.closePath();
    ctx.fillStyle = base.isPeaceful ? "#55aa88" : (base.shieldActive ? "#5566ff" : "#888888");
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#ffffff";
    ctx.stroke();
    ctx.restore();

    if (!base.isPeaceful) {
      for (const t of base.turrets) {
        if (!t.alive) continue;
        const ts = worldToScreen(t.worldX, t.worldY);
        const angleToShip = Math.atan2(ship.y - t.worldY, ship.x - t.worldX);

        ctx.save();
        ctx.translate(ts.x, ts.y);
        ctx.rotate(angleToShip);
        ctx.beginPath();
        const tr = 9;
        ctx.moveTo(tr, 0);
        ctx.lineTo(-tr * 0.6, tr * 0.7);
        ctx.lineTo(-tr * 0.6, -tr * 0.7);
        ctx.closePath();
        ctx.fillStyle = "#ff9999";
        ctx.fill();
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = "#ffffff";
        ctx.stroke();
        ctx.restore();
      }

      const hpRatio = base.hp / base.maxHp;
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(bs.x - 30, bs.y - base.size - 16, 60, 6);
      ctx.fillStyle = "#ffcc66";
      ctx.fillRect(bs.x - 30, bs.y - base.size - 16, 60 * hpRatio, 6);
    } else {
      ctx.font = "11px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#c1ffd1";
      ctx.fillText("Торговая база", bs.x, bs.y - base.size - 12);
    }
  }

  for (const l of state.loot) {
    const pos = worldToScreen(l.x, l.y);
    const pulse = 1 + 0.1 * Math.sin(l.t * 5);
    ctx.save();
    ctx.translate(pos.x, pos.y);
    ctx.rotate(l.t * 4);
    ctx.beginPath();
    ctx.rect(-l.radius * pulse, -l.radius * pulse, l.radius * 2 * pulse, l.radius * 2 * pulse);
    ctx.fillStyle = "#ffd966";
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#ffffff";
    ctx.stroke();
    ctx.restore();
  }

  for (const p of state.particles) {
    const pos = worldToScreen(p.x, p.y);
    const alpha = Math.max(p.life / p.maxLife, 0);
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, p.size, 0, TAU);
    ctx.fillStyle = p.color;
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  for (const b of state.bullets) {
    const pos = worldToScreen(b.x, b.y);
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, b.radius, 0, TAU);
    ctx.fillStyle = b.color || (b.hostile ? "#ff4d4d" : "#ffffaa");
    ctx.fill();
  }

  for (const e of state.enemies) {
    if (!e.alive) continue;
    const pos = worldToScreen(e.x, e.y);
    ctx.save();
    const angle = Math.atan2(ship.y - e.y, ship.x - e.x);
    ctx.translate(pos.x, pos.y);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(e.radius, 0);
    ctx.lineTo(-e.radius * 0.8, e.radius * 0.7);
    ctx.lineTo(-e.radius * 0.5, 0);
    ctx.lineTo(-e.radius * 0.8, -e.radius * 0.7);
    ctx.closePath();
    ctx.fillStyle = "#ff5555";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#ffffff";
    ctx.stroke();
    ctx.restore();
  }

  const shipPos = worldToScreen(ship.x, ship.y);
  const hullCur = state.currentHull;
  const shipColor = (hullCur && hullCur.abilityType === "aura") ? "#ff8888" : "#66d9ff";
  const shipShape = hullCur ? hullCur.shape : "arrow";

  if (hullCur && hullCur.abilityType === "aura") {
    ctx.beginPath();
    ctx.arc(shipPos.x, shipPos.y, 280, 0, TAU);
    ctx.strokeStyle = "rgba(255,120,120,0.2)";
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  drawShipIcon(shipPos.x, shipPos.y, ship.angle, ship.radius, shipColor, shipShape);

  drawHUD(false);
}

function drawHyperJumpScene() {
  const w = canvas.width;
  const h = canvas.height;
  const centerX = w / 2;
  const centerY = h / 2;

  const hj = state.hyperJump;
  const t = clamp(hj.t / hj.duration, 0, 1);

  const grad = ctx.createRadialGradient(
    centerX, centerY, 0,
    centerX, centerY, Math.max(w, h)
  );
  grad.addColorStop(0, "#ffffff");
  grad.addColorStop(0.2, "#88ccff");
  grad.addColorStop(1, "#000010");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, w, h);

  const streaks = 160;
  for (let i = 0; i < streaks; i++) {
    const angle = (i / streaks) * TAU + t * 10;
    const inner = 20 + 50 * (1 - t);
    const outer = Math.max(w, h) * 0.7 + 200 * t;
    const x1 = centerX + Math.cos(angle) * inner;
    const y1 = centerY + Math.sin(angle) * inner;
    const x2 = centerX + Math.cos(angle) * outer;
    const y2 = centerY + Math.sin(angle) * outer;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = "rgba(255,255,255," + (0.2 + 0.5 * (1 - t)) + ")";
    ctx.lineWidth = 1 + 2 * (1 - t);
    ctx.stroke();
  }

  const hullCur = state.currentHull;
  const shape = hullCur ? hullCur.shape : "arrow";
  drawShipIcon(centerX, centerY, state.ship.angle + state.time * 4, 18, "#66d9ff", shape);

  ctx.save();
  ctx.font = "16px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillStyle = "#000000";
  ctx.fillText("Гиперпрыжок...", centerX, 20);
  ctx.fillStyle = "#ffffff";
  ctx.fillText(
    "Из системы [" + state.hyperJump.fromX + ", " + state.hyperJump.fromY + "]",
    centerX,
    40
  );
  ctx.fillText(
    "В систему [" + state.hyperJump.toX + ", " + state.hyperJump.toY + "]",
    centerX,
    60
  );
  ctx.restore();
}

function drawHUD(skipPanels) {
  const w = canvas.width;
  const h = canvas.height;
  const sys = state.starSystem;
  const ship = state.ship;
  const ps = state.playerStats;
  const diff = sys ? (sys.difficulty || 1) : 1;
  const aliveBases = sys ? sys.bases.filter(b => b.alive && !b.isPeaceful).length : 0;
  const systemCleared = sys ? isSystemCleared(sys) : false;

  if (!skipPanels) {
    ctx.save();
    ctx.font = "14px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
    ctx.textBaseline = "top";
    ctx.textAlign = "left";

    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.fillRect(10, 10, 460, 120);

    ctx.fillStyle = "#ffffff";
    ctx.fillText(
      "Система [" + state.systemX + ", " + state.systemY + "] – " + (sys ? sys.name : ""),
      20,
      20
    );
    ctx.fillText("Сложность: " + diff.toFixed(2) + (systemCleared ? " (зачищена)" : ""), 20, 38);
    ctx.fillText(
      "Корабль: " + (state.currentHull ? state.currentHull.name : "нет") +
      " (" + state.inventory.ownedHullIndices.length + " в ангаре)",
      20,
      56
    );
    ctx.fillText("Двигатель: " + state.currentEngine.name, 20, 74);
    ctx.fillText(
      "Оружие: " + (state.currentWeapon ? state.currentWeapon.name : "нет"),
      20,
      92
    );
    ctx.fillText("Боевых баз в системе: " + aliveBases, 20, 110);

    const barWidth = 260;
    const barHeight = 18;
    const bx = 20;
    const by = h - 40;
    const hpRatio = ship.hp / ship.maxHp;
    ctx.fillStyle = "rgba(255,255,255,0.15)";
    ctx.fillRect(bx, by, barWidth, barHeight);
    ctx.fillStyle =
      hpRatio > 0.5 ? "#5cff7e" : hpRatio > 0.2 ? "#ffd75c" : "#ff4f4f";
    ctx.fillRect(bx, by, barWidth * hpRatio, barHeight);
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255,255,255,0.8)";
    ctx.strokeRect(bx, by, barWidth, barHeight);

    const panelW = 520;
    const px = w - 20;
    const py = h - 190;
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.fillRect(px - panelW, py - 100, panelW, 110);

    ctx.textAlign = "right";
    ctx.fillStyle = "#ffffff";
    ctx.fillText(
      "Уровень: " + ps.level + " | XP: " + ps.xp.toFixed(0) + " / " + ps.xpToNext,
      px - 10,
      py - 94
    );
    ctx.fillText(
      "Очки улучшений: " + ps.upgradePoints +
      " (Z/X/C/V/B – корабль, N – энергия)",
      px - 10,
      py - 78
    );

    const en = state.energy;
    const energyText = "Кредиты: " + state.credits +
      "   Энергия: " + Math.round(en.current) + " / " + Math.round(en.max);
    ctx.fillText(energyText, px - 10, py - 62);
    ctx.fillText("M – карта галактики, E – меню корабля", px - 10, py - 46);
    ctx.fillText("ЛКМ – поворот, Space – огонь, W/S – тяга", px - 10, py - 30);

    ctx.restore();
  }

  if (state.message && state.messageTimer > 0) {
    const w2 = canvas.width;
    ctx.save();
    ctx.font = "16px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    const text = state.message;
    const textWidth = ctx.measureText(text).width + 40;
    const x = w2 / 2;
    const y = 18;
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(x - textWidth / 2, y - 4, textWidth, 28);
    ctx.fillStyle = "#ffffff";
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  uiClickRegions = [];
  if (state.ui.mapOpen) {
    drawGalaxyMap();
  } else if (state.ui.paused) {
    drawPauseMenu();
  }
}

function drawPauseMenu() {
  const w = canvas.width;
  const h = canvas.height;
  const sys = state.starSystem;
  const systemCleared = sys ? isSystemCleared(sys) : false;

  const panelW = Math.min(950, w - 80);
  const panelH = Math.min(540, h - 80);
  const x = (w - panelW) / 2;
  const y = (h - panelH) / 2;

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.8)";
  ctx.fillRect(x, y, panelW, panelH);
  ctx.strokeStyle = "rgba(255,255,255,0.4)";
  ctx.lineWidth = 2;
  ctx.strokeRect(x, y, panelW, panelH);

  ctx.font = "18px system-ui";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillStyle = "#ffffff";
  ctx.fillText("Меню корабля – система [" + state.systemX + ", " + state.systemY + "]", x + 20, y + 16);

  const safeTxt = systemCleared ? "Система зачищена – модификации разрешены" :
    "Система не зачищена – модификации запрещены";
  ctx.font = "13px system-ui";
  ctx.fillStyle = systemCleared ? "#7dff7d" : "#ff7777";
  ctx.fillText(safeTxt, x + 20, y + 40);

  const tabNames = [
    { key: "main", label: "Главное" },
    { key: "hangar", label: "Ангар" },
    { key: "engine", label: "Двигатель" },
    { key: "weapon", label: "Оружие" },
    { key: "trade", label: "Торговля" },
    { key: "quests", label: "Квесты" }
  ];
  const tabX = x + 20;
  let tx = tabX;
  const ty = y + 70;
  ctx.font = "14px system-ui";

  for (const t of tabNames) {
    const tw = ctx.measureText(t.label).width + 20;
    const th = 22;
    const isActive = state.ui.tab === t.key;
    const disabled = (t.key !== "main" && t.key !== "trade" && t.key !== "quests" && !systemCleared);

    ctx.fillStyle = disabled ? "rgba(80,80,80,0.9)" :
      (isActive ? "#444466" : "#222233");
    ctx.fillRect(tx, ty, tw, th);
    ctx.strokeStyle = "#8888aa";
    ctx.strokeRect(tx, ty, tw, th);
    ctx.fillStyle = disabled ? "#777777" : "#ffffff";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(t.label, tx + tw / 2, ty + th / 2);

    const tabKey = t.key;
    if (!disabled) {
      addUIClickRegion(tx, ty, tw, th, () => {
        state.ui.tab = tabKey;
      });
    }

    tx += tw + 10;
  }

  const resetW = 100;
  const resetH = 24;
  const rx = x + panelW - resetW - 20;
  const ry = ty;
  ctx.fillStyle = "#662222";
  ctx.fillRect(rx, ry, resetW, resetH);
  ctx.strokeStyle = "#ffaaaa";
  ctx.strokeRect(rx, ry, resetW, resetH);
  ctx.fillStyle = "#ffaaaa";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("Сброс", rx + resetW / 2, ry + resetH / 2);
  addUIClickRegion(rx, ry, resetW, resetH, () => {
    resetGame();
  });

  const innerX = x + 20;
  const innerY = y + 110;
  const innerW = panelW - 40;
  const innerH = panelH - 130;

  ctx.save();
  ctx.beginPath();
  ctx.rect(innerX, innerY, innerW, innerH);
  ctx.clip();

  if (state.ui.tab === "main") {
    ctx.fillStyle = "#ffffff";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.font = "14px system-ui";
    ctx.fillText("Q – назад/выход из меню", innerX, innerY);
    ctx.fillText("Модификации корпуса/оружия/двигателя и апгрейды доступны только в зачищенных системах.", innerX, innerY + 20);
    ctx.fillText("M – мини-карта галактики, прыжки с расходом энергии (клик по системе).", innerX, innerY + 40);
  } else if (state.ui.tab === "hangar") {
    drawHangarTab(innerX, innerY, innerW, innerH, systemCleared);
  } else if (state.ui.tab === "engine") {
    drawEngineTab(innerX, innerY, innerW, innerH, systemCleared);
  } else if (state.ui.tab === "weapon") {
    drawWeaponTab(innerX, innerY, innerW, innerH, systemCleared);
  } else if (state.ui.tab === "trade") {
    drawTradeTab(innerX, innerY, innerW, innerH);
  } else if (state.ui.tab === "quests") {
    drawQuestsTab(innerX, innerY, innerW, innerH);
  }

  ctx.restore();
  ctx.restore();
}

function drawHangarTab(ix, iy, iw, ih, systemCleared) {
  const inv = state.inventory;
  ctx.fillStyle = "#ffffff";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.font = "14px system-ui";
  ctx.fillText("Ангар (клик по кораблю – выбрать). Вращение модели – просто анимация.", ix, iy);

  const listX = ix;
  const listY = iy + 24;
  const listW = iw * 0.55;
  const previewX = ix + listW + 20;
  const previewY = iy + 24;

  const rowH = 22;
  let y = listY;
  ctx.font = "13px system-ui";

  for (let i = 0; i < inv.ownedHullIndices.length; i++) {
    const hullIndex = inv.ownedHullIndices[i];
    const hull = hullTypes[hullIndex];
    const isActive = (i === inv.activeHullIndex);

    const bg = isActive ? "rgba(80,120,200,0.8)" : "rgba(40,40,60,0.6)";
    ctx.fillStyle = bg;
    ctx.fillRect(listX, y, listW, rowH - 2);
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.strokeRect(listX, y, listW, rowH - 2);
    ctx.fillStyle = "#ffffff";
    ctx.fillText(hull.name, listX + 6, y + 3);

    const info = "HP:" + hull.maxHp + "  V:" + hull.maxSpeed.toFixed(0) + "  T:" + hull.thrust.toFixed(0);
    ctx.fillStyle = "#ccccff";
    ctx.fillText(info, listX + 220, y + 3);

    if (systemCleared) {
      const indexInList = i;
      addUIClickRegion(listX, y, listW, rowH - 2, () => {
        state.inventory.activeHullIndex = indexInList;
        applyBuild(true);
        saveGame();
      });
    }

    y += rowH;
    if (y > iy + ih - 30) break;
  }

  const hull = state.currentHull;
  if (hull) {
    ctx.font = "14px system-ui";
    ctx.fillStyle = "#ffffff";
    ctx.fillText("Текущий корабль: " + hull.name, previewX, previewY);

    const centerX = previewX + iw * 0.25;
    const centerY = previewY + 80;
    const angle = state.time * 0.8;
    drawShipIcon(centerX, centerY, angle, hull.radius * 1.8, "#66d9ff", hull.shape);

    ctx.font = "13px system-ui";
    const lines = [
      "Класс: " + hull.desc,
      "Радиус: " + hull.radius.toFixed(1),
      "Макс. HP: " + hull.maxHp,
      "Тяга: " + hull.thrust.toFixed(0),
      "Макс. скорость: " + hull.maxSpeed.toFixed(0),
      "Реген: " + hull.regen.toFixed(1),
      hull.abilityType ? ("Способность: " + hull.abilityDesc) : "",
      "Цена (примерно): " + hullPrice(hull)
    ];
    let yy = centerY + 60;
    for (const line of lines) {
      if (!line) continue;
      ctx.fillStyle = "#ffffff";
      ctx.fillText(line, previewX, yy);
      yy += 18;
    }
  }

  if (!systemCleared) {
    ctx.fillStyle = "rgba(0,0,0,0.75)";
    ctx.fillRect(ix, iy + ih - 40, iw, 30);
    ctx.fillStyle = "#ff7777";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Изменение корабля запрещено: система не зачищена.", ix + iw / 2, iy + ih - 25);
  }
}

function drawEngineTab(ix, iy, iw, ih, systemCleared) {
  ctx.fillStyle = "#ffffff";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.font = "14px system-ui";
  ctx.fillText("Двигатели (клик – выбрать).", ix, iy);

  const rowH = 26;
  let y = iy + 24;
  ctx.font = "13px system-ui";
  for (let i = 0; i < engineModules.length; i++) {
    const e = engineModules[i];
    const isActive = (i === state.build.engine);
    const owned = state.inventory.ownedEngineIndices.includes(i);
    const bg = !owned ? "rgba(30,30,30,0.6)" :
      (isActive ? "rgba(80,120,200,0.8)" : "rgba(40,40,60,0.6)");
    ctx.fillStyle = bg;
    ctx.fillRect(ix, y, iw, rowH - 2);
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.strokeRect(ix, y, iw, rowH - 2);

    ctx.fillStyle = owned ? "#ffffff" : "#777777";
    ctx.fillText(e.name + (owned ? "" : " (нет)"), ix + 6, y + 4);
    ctx.fillStyle = owned ? "#ccccff" : "#555555";
    ctx.fillText("Множитель скорости: " + e.speedFactor.toFixed(2), ix + 250, y + 4);
    ctx.fillStyle = "#aaaaaa";
    ctx.fillText(e.desc, ix + 6, y + 4 + 16);

    if (systemCleared && owned) {
      const idx = i;
      addUIClickRegion(ix, y, iw, rowH - 2, () => {
        setEngine(idx);
      });
    }

    y += rowH;
  }

  if (!systemCleared) {
    ctx.fillStyle = "rgba(0,0,0,0.75)";
    ctx.fillRect(ix, iy + ih - 40, iw, 30);
    ctx.fillStyle = "#ff7777";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Изменение двигателя запрещено: система не зачищена.", ix + iw / 2, iy + ih - 25);
  }
}

function drawWeaponTab(ix, iy, iw, ih, systemCleared) {
  ctx.fillStyle = "#ffffff";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.font = "14px system-ui";
  ctx.fillText("Оружие (клик – выбрать).", ix, iy);

  const listW = iw * 0.55;
  const previewX = ix + listW + 20;
  const previewY = iy + 24;

  const rowH = 26;
  let y = iy + 24;
  ctx.font = "13px system-ui";

  for (let i = 0; i < weaponTypes.length; i++) {
    const wType = weaponTypes[i];
    const owned = state.inventory.ownedWeaponIndices.includes(i);
    const isActive = (i === state.build.weapon);
    const bg = !owned ? "rgba(30,30,30,0.6)" :
      (isActive ? "rgba(80,120,200,0.8)" : "rgba(40,40,60,0.6)");
    ctx.fillStyle = bg;
    ctx.fillRect(ix, y, listW, rowH - 2);
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.strokeRect(ix, y, listW, rowH - 2);

    ctx.fillStyle = owned ? "#ffffff" : "#777777";
    ctx.fillText(wType.name + " [" + wType.type + "]", ix + 6, y + 4);
    const bullets = wType.projectiles;
    const dps = (wType.damage * wType.projectiles) / Math.max(0.05, wType.cooldown);
    ctx.fillStyle = owned ? "#ccccff" : "#555555";
    ctx.fillText(
      "Пуль/шот: " + bullets + "  DPS≈" + dps.toFixed(1),
      ix + 230,
      y + 4
    );

    if (owned && systemCleared) {
      const idx = i;
      addUIClickRegion(ix, y, listW, rowH - 2, () => {
        setWeapon(idx);
      });
    }

    y += rowH;
  }

  const wCur = state.currentWeapon;
  if (wCur) {
    ctx.font = "14px system-ui";
    ctx.fillStyle = "#ffffff";
    ctx.fillText("Текущее оружие: " + wCur.name, previewX, previewY);

    ctx.font = "13px system-ui";
    const dps = (wCur.damage * wCur.projectiles) / Math.max(0.05, wCur.cooldown);
    const lines = [
      "Тип: " + wCur.type,
      "Пуль за выстрел: " + wCur.projectiles,
      "Урон за пулю: " + wCur.damage.toFixed(2),
      "Кулдаун: " + wCur.cooldown.toFixed(2) + " c",
      "DPS ≈ " + dps.toFixed(2),
      "Скорость пули: " + wCur.bulletSpeed.toFixed(0),
      "Цвет пуль: " + wCur.color,
      wCur.explosiveRadius && wCur.explosiveRadius > 0
        ? "Радиус взрыва: " + wCur.explosiveRadius
        : "",
      "Описание: " + wCur.desc
    ];
    let yy = previewY + 20;
    for (const line of lines) {
      if (!line) continue;
      ctx.fillStyle = "#ffffff";
      ctx.fillText(line, previewX, yy);
      yy += 18;
    }
  }

  if (!systemCleared) {
    ctx.fillStyle = "rgba(0,0,0,0.75)";
    ctx.fillRect(ix, iy + ih - 40, iw, 30);
    ctx.fillStyle = "#ff7777";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Изменение оружия запрещено: система не зачищена.", ix + iw / 2, iy + ih - 25);
  }
}

function sellCurrentHull(trade) {
  const inv = state.inventory;
  if (inv.ownedHullIndices.length <= 1) {
    showMessage("Нельзя продать последний корабль.");
    return;
  }
  const hullIndex = inv.ownedHullIndices[inv.activeHullIndex];
  const hull = hullTypes[hullIndex];
  const sellPrice = Math.round(hullPrice(hull) * (trade.buyModifier || 0.4) * 0.5);
  state.credits += sellPrice;
  inv.ownedHullIndices.splice(inv.activeHullIndex, 1);
  inv.activeHullIndex = clamp(inv.activeHullIndex, 0, inv.ownedHullIndices.length - 1);
  applyBuild(true);
  saveGame();
  showMessage("Продан корабль: " + hull.name + " за " + sellPrice + " кр");
}

function sellCurrentWeapon(trade) {
  const inv = state.inventory;
  if (inv.ownedWeaponIndices.length <= 1) {
    showMessage("Нельзя продать единственное оружие.");
    return;
  }
  const wid = state.build.weapon;
  const idx = inv.ownedWeaponIndices.indexOf(wid);
  if (idx < 0) {
    showMessage("Это оружие нельзя продать.");
    return;
  }
  const wType = weaponTypes[wid];
  const sellPrice = Math.round(weaponPrice(wType) * (trade.buyModifier || 0.4) * 0.5);
  state.credits += sellPrice;
  inv.ownedWeaponIndices.splice(idx, 1);
  state.build.weapon = inv.ownedWeaponIndices[0] ?? 0;
  applyBuild(true);
  saveGame();
  showMessage("Продано оружие: " + wType.name + " за " + sellPrice + " кр");
}

function sellCurrentEngine(trade) {
  const inv = state.inventory;
  if (inv.ownedEngineIndices.length <= 1) {
    showMessage("Нельзя продать единственный двигатель.");
    return;
  }
  const eid = state.build.engine;
  const idx = inv.ownedEngineIndices.indexOf(eid);
  if (idx < 0) {
    showMessage("Этот двигатель нельзя продать.");
    return;
  }
  const e = engineModules[eid];
  const sellPrice = Math.round(enginePrice(e) * (trade.buyModifier || 0.4) * 0.5);
  state.credits += sellPrice;
  inv.ownedEngineIndices.splice(idx, 1);
  state.build.engine = inv.ownedEngineIndices[0] ?? 0;
  applyBuild(true);
  saveGame();
  showMessage("Продан двигатель: " + e.name + " за " + sellPrice + " кр");
}

function drawTradeTab(ix, iy, iw, ih) {
  const sys = state.starSystem;
  ctx.font = "14px system-ui";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";

  if (!sys) {
    ctx.fillStyle = "#ffffff";
    ctx.fillText("Нет системы.", ix, iy);
    return;
  }

  const systemCleared = isSystemCleared(sys);

  let nearestBase = null;
  let nearestDist = Infinity;
  const ship = state.ship;
  for (const b of sys.bases) {
    if (!b.isPeaceful || !b.alive || !b.trade) continue;
    const dx = ship.x - b.x;
    const dy = ship.y - b.y;
    const d = Math.hypot(dx, dy);
    if (d < nearestDist) {
      nearestDist = d;
      nearestBase = b;
    }
  }

  if (!nearestBase) {
    ctx.fillStyle = "#ffffff";
    ctx.fillText("В этой системе нет мирных торговых баз.", ix, iy);
    return;
  }

  if (!systemCleared) {
    ctx.fillStyle = "#ff7777";
    ctx.fillText("Торговля заблокирована: система не зачищена.", ix, iy);
    return;
  }

  if (nearestDist > nearestBase.size + 260) {
    ctx.fillStyle = "#ffffff";
    ctx.fillText("Подлети ближе к торговой базе для доступа к рынку.", ix, iy);
    ctx.fillText("(Сейчас расстояние ≈ " + nearestDist.toFixed(0) + ")", ix, iy + 20);
    return;
  }

  const trade = nearestBase.trade;
  ctx.fillStyle = "#ffffff";
  ctx.fillText("Торговая база: покупка / продажа модулей.", ix, iy);
  ctx.fillText("Кредиты: " + state.credits, ix, iy + 20);

  const colW = iw / 3;
  const colH = ih - 90;

  ctx.font = "13px system-ui";

  let cx = ix;
  let cy = iy + 40;
  ctx.fillStyle = "#ffffaa";
  ctx.fillText("Корабли", cx, cy);
  cy += 6;
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(cx, cy + 12, colW - 10, colH - 20);

  cy += 16;
  let yy = cy;
  for (const offer of trade.hullOffers) {
    const hull = hullTypes[offer.hullIndex];
    const owned = state.inventory.ownedHullIndices.includes(offer.hullIndex);
    const price = offer.price;
    if (yy > iy + ih - 120) break;

    ctx.fillStyle = owned ? "rgba(0,100,0,0.4)" : "rgba(0,0,0,0.4)";
    ctx.fillRect(cx + 4, yy, colW - 18, 40);
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.strokeRect(cx + 4, yy, colW - 18, 40);

    ctx.fillStyle = "#ffffff";
    ctx.fillText(hull.name, cx + 8, yy + 4);
    ctx.fillStyle = "#ccccff";
    ctx.fillText("HP:" + hull.maxHp + " V:" + hull.maxSpeed.toFixed(0), cx + 8, yy + 20);
    ctx.fillStyle = owned ? "#77ff77" : "#ffdd77";
    ctx.fillText((owned ? "Есть" : "Цена: " + price), cx + colW - 22 - 80, yy + 4);

    if (!owned) {
      addUIClickRegion(cx + 4, yy, colW - 18, 40, () => {
        if (state.credits >= price) {
          state.credits -= price;
          state.inventory.ownedHullIndices.push(offer.hullIndex);
          saveGame();
          showMessage("Корабль куплен: " + hull.name);
        } else {
          showMessage("Недостаточно кредитов.");
        }
      });
    }

    yy += 44;
  }

  cx = ix + colW;
  cy = iy + 40;
  ctx.fillStyle = "#ffffaa";
  ctx.fillText("Оружие", cx, cy);
  cy += 6;
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(cx, cy + 12, colW - 10, colH - 20);
  cy += 16;
  yy = cy;

  for (const offer of trade.weaponOffers) {
    const wType = weaponTypes[offer.weaponIndex];
    const owned = state.inventory.ownedWeaponIndices.includes(offer.weaponIndex);
    const price = offer.price;
    if (yy > iy + ih - 120) break;

    ctx.fillStyle = owned ? "rgba(0,100,0,0.4)" : "rgba(0,0,0,0.4)";
    ctx.fillRect(cx + 4, yy, colW - 18, 40);
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.strokeRect(cx + 4, yy, colW - 18, 40);

    ctx.fillStyle = "#ffffff";
    ctx.fillText(wType.name, cx + 8, yy + 4);
    ctx.fillStyle = "#ccccff";
    ctx.fillText("Тип: " + wType.type, cx + 8, yy + 20);
    ctx.fillStyle = owned ? "#77ff77" : "#ffdd77";
    ctx.fillText((owned ? "Есть" : "Цена: " + price), cx + colW - 22 - 80, yy + 4);

    if (!owned) {
      addUIClickRegion(cx + 4, yy, colW - 18, 40, () => {
        if (state.credits >= price) {
          state.credits -= price;
          state.inventory.ownedWeaponIndices.push(offer.weaponIndex);
          saveGame();
          showMessage("Оружие куплено: " + wType.name);
        } else {
          showMessage("Недостаточно кредитов.");
        }
      });
    }

    yy += 44;
  }

  cx = ix + colW * 2;
  cy = iy + 40;
  ctx.fillStyle = "#ffffaa";
  ctx.fillText("Двигатели", cx, cy);
  cy += 6;
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(cx, cy + 12, colW - 10, colH - 20);
  cy += 16;
  yy = cy;

  for (const offer of trade.engineOffers) {
    const e = engineModules[offer.engineIndex];
    const price = offer.price;
    const owned = state.inventory.ownedEngineIndices.includes(offer.engineIndex);
    if (yy > iy + ih - 120) break;

    ctx.fillStyle = owned ? "rgba(0,100,0,0.4)" : "rgba(0,0,0,0.4)";
    ctx.fillRect(cx + 4, yy, colW - 18, 40);
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.strokeRect(cx + 4, yy, colW - 18, 40);

    ctx.fillStyle = "#ffffff";
    ctx.fillText(e.name, cx + 8, yy + 4);
    ctx.fillStyle = "#ccccff";
    ctx.fillText("x" + e.speedFactor.toFixed(2) + " к скорости", cx + 8, yy + 20);
    ctx.fillStyle = owned ? "#77ff77" : "#ffdd77";
    ctx.fillText((owned ? "Есть" : "Цена: " + price), cx + colW - 22 - 80, yy + 4);

    if (!owned) {
      addUIClickRegion(cx + 4, yy, colW - 18, 40, () => {
        if (state.credits >= price) {
          state.credits -= price;
          state.inventory.ownedEngineIndices.push(offer.engineIndex);
          saveGame();
          showMessage("Двигатель куплен: " + e.name);
        } else {
          showMessage("Недостаточно кредитов.");
        }
      });
    }

    yy += 44;
  }

  let sy = iy + ih - 70;
  ctx.fillStyle = "#ffffff";
  ctx.fillText("Продажа текущих модулей:", ix, sy);
  sy += 6;

  const btnW = 220;
  const btnH = 22;

  const hull = state.currentHull;
  if (hull && state.inventory.ownedHullIndices.length > 1) {
    const bx = ix;
    const by = sy;
    const sellPrice = Math.round(hullPrice(hull) * (trade.buyModifier || 0.4) * 0.5);
    ctx.fillStyle = "#332222";
    ctx.fillRect(bx, by, btnW, btnH);
    ctx.strokeStyle = "#ffaaaa";
    ctx.strokeRect(bx, by, btnW, btnH);
    ctx.fillStyle = "#ffaaaa";
    ctx.fillText("Продать корабль (" + sellPrice + " кр)", bx + 6, by + 5);
    addUIClickRegion(bx, by, btnW, btnH, () => sellCurrentHull(trade));
  }

  sy += 26;
  const wCur = state.currentWeapon;
  if (wCur && state.inventory.ownedWeaponIndices.length > 1) {
    const bx = ix;
    const by = sy;
    const sellPrice = Math.round(weaponPrice(weaponTypes[state.build.weapon]) *
      (trade.buyModifier || 0.4) * 0.5);
    ctx.fillStyle = "#332222";
    ctx.fillRect(bx, by, btnW, btnH);
    ctx.strokeStyle = "#ffaaaa";
    ctx.strokeRect(bx, by, btnW, btnH);
    ctx.fillStyle = "#ffaaaa";
    ctx.fillText("Продать оружие (" + sellPrice + " кр)", bx + 6, by + 5);
    addUIClickRegion(bx, by, btnW, btnH, () => sellCurrentWeapon(trade));
  }

  const eCur = state.currentEngine;
  if (eCur && state.inventory.ownedEngineIndices.length > 1) {
    const bx = ix + btnW + 20;
    const by = iy + ih - 44;
    const sellPrice = Math.round(enginePrice(engineModules[state.build.engine]) *
      (trade.buyModifier || 0.4) * 0.5);
    ctx.fillStyle = "#332222";
    ctx.fillRect(bx, by, btnW, btnH);
    ctx.strokeStyle = "#ffaaaa";
    ctx.strokeRect(bx, by, btnW, btnH);
    ctx.fillStyle = "#ffaaaa";
    ctx.fillText("Продать двигатель (" + sellPrice + " кр)", bx + 6, by + 5);
    addUIClickRegion(bx, by, btnW, btnH, () => sellCurrentEngine(trade));
  }
}

function drawQuestsTab(ix, iy, iw, ih) {
  const quests = state.quests;
  ctx.fillStyle = "#ffffff";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.font = "14px system-ui";
  ctx.fillText("Квесты", ix, iy);

  if (!quests) return;

  ctx.font = "13px system-ui";
  let y = iy + 24;
  ctx.fillStyle = "#ffffaa";
  ctx.fillText("Активные:", ix, y);
  y += 18;

  if (!quests.active.length) {
    ctx.fillStyle = "#cccccc";
    ctx.fillText("Нет активных квестов.", ix, y);
    y += 20;
  } else {
    for (const q of quests.active) {
      ctx.fillStyle = "#ffffff";
      ctx.fillText("• " + q.title, ix, y);
      y += 16;
      ctx.fillStyle = "#ccccff";
      const target = "[" + q.targetX + "," + q.targetY + "]";
      ctx.fillText("Цель: зачистить систему " + target, ix + 14, y);
      y += 16;
      ctx.fillStyle = "#77ff77";
      ctx.fillText("Награда: " + (q.rewardCredits || 0) + " кредитов, " + (q.rewardXp || 0) + " XP", ix + 14, y);
      y += 22;
      if (y > iy + ih - 60) break;
    }
  }

  y += 10;
  ctx.fillStyle = "#ffffaa";
  ctx.fillText("Завершённые:", ix, y);
  y += 18;

  if (!quests.completed.length) {
    ctx.fillStyle = "#cccccc";
    ctx.fillText("Пока нет.", ix, y);
    return;
  }

  for (const q of quests.completed) {
    if (y > iy + ih - 40) break;
    ctx.fillStyle = "#aaaaaa";
    ctx.fillText("• " + q.title, ix, y);
    y += 18;
  }
}

function drawGalaxyMap() {
  const w = canvas.width;
  const h = canvas.height;
  const cx = w / 2;
  const cy = h / 2;

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.9)";
  ctx.fillRect(0, 0, w, h);

  ctx.font = "18px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillStyle = "#ffffff";
  ctx.fillText("Карта галактики (M или Q – выход)", cx, 20);

  const scale = 30;
  const centerX = state.ui.mapCenterX;
  const centerY = state.ui.mapCenterY;

  ctx.font = "12px system-ui";
  for (const key in state.visitedSystems) {
    const [sx, sy] = key.split(",").map(Number);
    const dx = (sx - centerX) * scale;
    const dy = (sy - centerY) * scale;
    const x = cx + dx;
    const y = cy + dy;
    if (x < 50 || y < 60 || x > w - 50 || y > h - 90) continue;

    const isHome = (sx === 0 && sy === 0);
    const isCurrent = (sx === state.systemX && sy === state.systemY);

    ctx.beginPath();
    ctx.arc(x, y, isCurrent ? 7 : 5, 0, TAU);
    ctx.fillStyle = isHome ? "#66ff66" : (isCurrent ? "#66ccff" : "#bbbbff");
    ctx.fill();
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = isCurrent ? 2 : 1;
    ctx.stroke();

    ctx.fillStyle = "#ffffff";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillText("[" + sx + "," + sy + "]", x + 10, y);

    addUIClickRegion(x - 8, y - 8, 16, 16, () => {
      startMapJump(sx, sy);
    });
  }

  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillStyle = "#ffffff";
  const btnW = 200;
  const btnH = 26;
  const bx1 = 20;
  const by1 = h - 80;
  const bx2 = 240;
  const by2 = h - 80;

  ctx.fillStyle = "#223322";
  ctx.fillRect(bx1, by1, btnW, btnH);
  ctx.strokeStyle = "#77ff77";
  ctx.strokeRect(bx1, by1, btnW, btnH);
  ctx.fillStyle = "#77ff77";
  ctx.fillText("Домашняя система [0,0]", bx1 + 10, by1 + 7);
  addUIClickRegion(bx1, by1, btnW, btnH, () => {
    state.ui.mapCenterX = 0;
    state.ui.mapCenterY = 0;
  });

  ctx.fillStyle = "#223344";
  ctx.fillRect(bx2, by2, btnW, btnH);
  ctx.strokeStyle = "#66ccff";
  ctx.strokeRect(bx2, by2, btnW, btnH);
  ctx.fillStyle = "#66ccff";
  ctx.fillText("Текущая система [" + state.systemX + "," + state.systemY + "]", bx2 + 10, by2 + 7);
  addUIClickRegion(bx2, by2, btnW, btnH, () => {
    state.ui.mapCenterX = state.systemX;
    state.ui.mapCenterY = state.systemY;
  });

  const en = state.energy;
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillStyle = "#ffffff";
  ctx.fillText(
    "Энергия: " + Math.round(en.current) + " / " + Math.round(en.max) +
    ". Клик по посещённой системе – гиперпрыжок (расход энергии).",
    cx,
    h - 20
  );

  ctx.restore();
}


function loop(t) {
  const dt = Math.min((t - lastTime) / 1000, 0.05);
  lastTime = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}


applyBuild(false);
if (!loadGame()) {
  enterSystem(0, 0, 0, 0);
  showMessage("Домашняя система [0,0]. M – карта (прыжки по энергии), E – меню.");
} else {
  showMessage("Загружен сохранённый прогресс.");
}

requestAnimationFrame(loop);
</script>
</body>
</html>
